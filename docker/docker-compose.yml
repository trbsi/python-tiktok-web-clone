services:
  my-app-db:
    container_name: my-app-db
    networks:
      - my-network
    image: mysql:8.0
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "${MYSQL_HOST_PORT}:3306"
    volumes:
      - my_app_db_data:/var/lib/mysql
    healthcheck:
      test: CMD-SHELL mysqladmin ping -u$MYSQL_USER -p$MYSQL_PASSWORD || mysqladmin ping -uroot -p$MYSQL_ROOT_PASSWORD
      interval: 10s
      timeout: 5s
      retries: 10

  my-app-redis:
    container_name: my-app-redis
    networks:
      - my-network
    image: redis:7
    restart: unless-stopped
    volumes:
      - my_app_redis_data:/data

  my-app-phpmyadmin:
    container_name: my-app-phpmyadmin
    networks:
      - my-network
    image: phpmyadmin/phpmyadmin:latest
    restart: unless-stopped
    environment:
      PMA_HOST: my-app-db
      VIRTUAL_HOST: ${PHPMYADMIN_VIRTUAL_HOST}
    depends_on:
      - my-app-db
    expose:
      - 8000

  my-app-web:
    image: my-app-web-image
    container_name: my-app-web
    user: "${UID}:${GID}"
    networks:
      - my-network
    build:
      context: ..
      args:
        UID: ${UID}
        GID: ${GID}
      dockerfile: docker/web/Dockerfile
    restart: unless-stopped
    environment:
      # Required by nginx-proxy to proxy to gunicorn
      VIRTUAL_HOST: ${NGINX_VIRTUAL_HOST}
      VIRTUAL_PORT: 8000  # Gunicorn port inside the container
      DATABASE_URL: ${DATABASE_URL}
      REDIS_URL: redis://my-app-redis:6379/0
    #app.wsgi is path to app/wsgi.py
    command: >
      gunicorn app.wsgi:application
      --bind 0.0.0.0:8000
      --workers ${GUNICORN_WORKERS}
      --reload
      --log-level ${GUNICORN_LOG_LEVEL}
      --timeout 600
    depends_on:
      my-app-db:
        condition: service_healthy
      my-app-redis:
        condition: service_started
    expose:
      - 8000
    volumes:
      - ../:/app:cached
      - ../logs:/app/logs
      - my_app_static_volume:/app/staticfiles
      - my_app_media_volume:/app/uploads
      - geoip_volume:/app/geoip

  my-app-celery_worker:
    container_name: my-app-celery_worker
    networks:
      - my-network
    image: my-app-web-image
    command: celery -A ${CELERY_APP} worker --loglevel=info --concurrency=1
    environment:
      CELERY_BROKER_URL: redis://my-app-redis:6379/0
      CELERY_APP: ${CELERY_APP}
    volumes:
      - ../:/app:cached
      - my_app_media_volume:/app/uploads
    depends_on:
      - my-app-redis
      - my-app-db
      - my-app-web

  my-app-celery_beat:
    container_name: my-app-celery_beat
    networks:
      - my-network
    image: my-app-web-image
    user: "0:0" # so I can change permissions in "command"
    environment:
      UID: ${UID}
      GID: ${GID}
    command: >
      bash -c "ls -alh /app &&
        chown -R ${UID}:${GID} /app/celerybeat_data
        touch /app/celerybeat_data/celerybeat-schedule &&
        celery -A ${CELERY_APP} beat --loglevel=info --schedule=/app/celerybeat_data/celerybeat-schedule"
    volumes:
      - ../:/app:cached
      - my_app_media_volume:/app/uploads
      - my_app_celerybeat_data:/app/celerybeat_data
    depends_on:
      - my-app-redis
      - my-app-db
      - my-app-web

  my-app-nginx:
    container_name: my-app-nginx
    networks:
      - my-network
    image: jwilder/nginx-proxy:latest
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock:ro
      - ./nginx/vhost.d:/etc/nginx/vhost.d

networks:
  my-network:
    external: true

volumes:
  my_app_db_data:
  my_app_redis_data:
  my_app_static_volume:
  my_app_media_volume:
  my_app_celerybeat_data:
  geoip_volume:
