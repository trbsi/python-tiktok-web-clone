{% extends "core/layout.html" %}

{% block content %}

<!-- Video Feed View -->
<div
        x-data="videoFeed()"
        x-init="init()"
        class="min-h-screen bg-black text-white"
>
    <!-- Feed container: vertically snapping -->
    <div
            id="feed"
            class="h-screen overflow-y-auto snap-y snap-mandatory"
            @scroll.window.debounce="onScroll"
    >
        <!-- Video items -->
        <template x-for="(video, index) in videos" :key="video.id">
            <div
                    class="video-container relative h-screen snap-start flex items-center justify-center bg-black"
            >
                <!-- video element -->
                <video
                        x-ref="video"
                        :data-index="index"
                        :id="`video-${video.id}`"
                        class="w-full h-full object-cover"
                        playsinline
                        muted
                        loop
                        preload="metadata"
                        @timeupdate="updateProgress(index, $event)"
                        @loadeddata="onVideoLoaded(index)"
                >
                    <source :src="video.src" type="video/mp4"/>
                    Your browser does not support the video tag.
                </video>

                <!-- spinner loader while video buffering -->
                <div
                        x-show="loadingVideo[index]"
                        class="absolute inset-0 flex items-center justify-center bg-black/60"
                >
                    <div class="animate-spin rounded-full border-4 border-t-4 border-gray-300 w-12 h-12"></div>
                </div>

                <!-- Overlay -->
                <div class="video-overlay absolute inset-0 flex flex-col justify-between p-4 pointer-events-none">
                    <!-- Top bar -->
                    <div class="flex justify-between items-center pointer-events-auto">
                        <div class="text-2xl font-['Pacifico']">MyApp</div>
                        <div class="flex items-center gap-3 text-sm">
                            <a class="underline" href="#">Following</a>
                            <a class="underline" href="#">FYP</a>
                        </div>
                    </div>

                    <!-- Right action bar -->
                    <div class="action-bar absolute right-4 bottom-24 flex flex-col items-center gap-6 pointer-events-auto">
                        <!-- Like -->
                        <button
                                @click="toggleLike(video, index)"
                                class="w-12 h-12 flex flex-col items-center justify-center"
                                :class="{'text-red-500': video.liked}"
                                aria-label="Like"
                        >
                            <i x-html="video.liked ? '&#9829;' : '&#9825;'" class="text-2xl"></i>
                            <span class="text-xs mt-1" x-text="formatCount(video.likes)"></span>
                        </button>

                        <!-- Comment -->
                        <button
                                @click="openComments(video)"
                                class="w-12 h-12 flex flex-col items-center justify-center"
                                aria-label="Comments"
                        >
                            <i class="ri-chat-1-line ri-2x"></i>
                            <span class="text-xs mt-1" x-text="formatCount(video.comments_count)"></span>
                        </button>

                        <!-- Share -->
                        <button
                                @click="shareVideo(video)"
                                class="w-12 h-12 flex flex-col items-center justify-center"
                                aria-label="Share"
                        >
                            <i class="ri-share-forward-line ri-2x"></i>
                            <span class="text-xs mt-1">Share</span>
                        </button>

                        <!-- User avatar -->
                        <button @click="openProfile(video.user)" class="w-12 h-12 flex items-center justify-center">
                            <div class="w-10 h-10 rounded-full overflow-hidden border-2 border-white/30">
                                <img :src="video.user.avatar" alt="User" class="w-full h-full object-cover"/>
                            </div>
                        </button>
                    </div>

                    <!-- Bottom info -->
                    <div class="flex flex-col gap-2 mb-2 pointer-events-auto">
                        <div class="flex items-center gap-2">
                            <span class="font-semibold" x-text="`@${video.user.username}`"></span>
                            <button class="bg-primary text-white text-xs px-2 py-0.5 rounded-full">Follow</button>
                        </div>
                        <p class="text-sm" x-text="video.description"></p>
                    </div>
                </div>

                <!-- Bottom progress bar for this video -->
                <div class="absolute bottom-0 left-0 w-full h-1 bg-gray-700">
                    <div
                            class="h-full bg-primary"
                            :style="`width: ${progress[index] ?? 0}%`"
                    ></div>
                </div>
            </div>
        </template>

        <!-- skeleton loader cards while loading more -->
        <template x-if="loadingMore">
            <div class="space-y-4 p-6">
                <div class="h-96 bg-gray-800 animate-pulse rounded"></div>
                <div class="h-96 bg-gray-800 animate-pulse rounded"></div>
            </div>
        </template>

        <!-- final empty state -->
        <div x-show="!hasMore && !videos.length" class="p-8 text-center text-gray-400">
            No videos to show.
        </div>
    </div>

    <!-- Comments overlay -->
    <div
            x-show="commentsOpen"
            x-transition
            class="fixed inset-0 bg-black/70 flex items-end justify-center z-50"
            @keydown.escape.window="closeComments()"
    >
        <div class="bg-white text-black w-full max-w-xl h-3/4 rounded-t-xl overflow-hidden flex flex-col">
            <div class="flex items-center justify-between px-4 py-3 border-b">
                <h3 class="font-semibold">Comments</h3>
                <button @click="closeComments()" class="text-lg px-3">✕</button>
            </div>

            <div class="flex-1 overflow-y-auto p-4 space-y-4">
                <template x-if="commentsLoading">
                    <div class="space-y-2">
                        <div class="h-3 bg-gray-200 animate-pulse rounded w-1/2"></div>
                        <div class="h-3 bg-gray-200 animate-pulse rounded w-2/3"></div>
                    </div>
                </template>

                <template x-for="comment in comments" :key="comment.id">
                    <div class="flex items-start gap-3">
                        <img :src="comment.user.avatar" class="w-10 h-10 rounded-full object-cover"/>
                        <div>
                            <div class="text-sm font-semibold" x-text="comment.user.username"></div>
                            <div class="text-sm" x-text="comment.text"></div>
                            <div class="text-xs text-gray-500" x-text="comment.created_at"></div>
                        </div>
                    </div>
                </template>

                <div x-show="!comments.length && !commentsLoading" class="text-center text-gray-500">
                    No comments yet — be the first!
                </div>
            </div>

            <form @submit.prevent="submitComment()" class="p-4 border-t flex gap-2">
                <input
                        x-model="commentInput"
                        required
                        class="flex-1 rounded-full px-4 py-2 border"
                        placeholder="Add a comment..."
                />
                <button type="submit" class="bg-primary text-white px-4 py-2 rounded-full">Send</button>
            </form>
        </div>
    </div>
</div>

<script>
    function videoFeed() {
      return {
        videos: [],                // list of video objects
        page: 1,                   // pagination
        loadingMore: false,
        hasMore: true,
        currentIndex: 0,
        observer: null,
        progress: {},              // progress per index (0..100)
        loadingVideo: {},          // buffering flags per index
        commentsOpen: false,
        comments: [],
        commentsLoading: false,
        commentInput: '',
        activeVideo: null,         // currently opened video for comments
        perPage: 10,               // how many videos per fetch

        init() {
          // initial load
          this.loadMore();

          // set up an IntersectionObserver to detect which video is in view
          // We'll create the observer after a short delay so DOM nodes exist after first load.
          this.$nextTick(() => {
            // observe via polling for refs available
            const waitForRefs = () => {
              if (!this.$refs.video || !this.$refs.video.length) {
                setTimeout(waitForRefs, 100);
                return;
              }
              this.setupObserver();
            };
            waitForRefs();
          });

          // pause all videos on page load, then play the top-most after a tiny delay for autoplay to work consistently
          window.addEventListener('visibilitychange', () => {
            if (document.hidden) this.pauseAll();
            else this.playCurrent();
          });
        },

        async loadMore() {
          if (this.loadingMore || !this.hasMore) return;
          this.loadingMore = true;
          try {
            const res = await fetch(`/api/videos?page=${this.page}&per_page=${this.perPage}`);
            if (!res.ok) throw new Error('Failed to fetch videos');
            const data = await res.json();

            // expected response shape: { results: [...], next_page: 2/null }
            const items = data.results || data;
            items.forEach(v => {
              // normalize fields we use:
              v.likes = v.likes ?? 0;
              v.liked = !!v.liked;
              v.comments_count = v.comments_count ?? 0;
              v.user = v.user || { username: 'unknown', avatar: 'https://via.placeholder.com/150' };
              v.description = v.description ?? '';
            });

            this.videos = this.videos.concat(items);
            this.page = data.next_page ?? (this.page + 1);
            this.hasMore = !!data.next_page;

            // after adding new items we need to re-run observer
            this.$nextTick(() => {
              if (this.observer) {
                this.$refs.video.forEach(el => this.observer.observe(el));
              } else {
                this.setupObserver();
              }
            });
          } catch (e) {
            console.error(e);
          } finally {
            this.loadingMore = false;
          }
        },

        setupObserver() {
          // clean up if exists
          if (this.observer) {
            try {
              this.$refs.video.forEach(el => this.observer.unobserve(el));
            } catch (e) {}
            this.observer.disconnect();
          }

          // Options tuned so video considered "in view" when >=60% visible
          this.observer = new IntersectionObserver((entries) => {
            // choose the entry with highest intersectionRatio
            let best = null;
            entries.forEach(entry => {
              if (!best || entry.intersectionRatio > best.intersectionRatio) best = entry;
            });
            if (!best) return;

            // find index for the entry target
            const index = parseInt(best.target.getAttribute('data-index'));
            if (best.intersectionRatio >= 0.6) {
              // pause other videos, play this one
              this.currentIndex = index;
              this.playAtIndex(index);
              // if we are 5th before end, load more
              if (this.videos.length - index <= 5) {
                this.loadMore();
              }
            } else {
              // not enough visible
              // optional: pause
              // this.pauseAtIndex(index)
            }
          }, { threshold: [0, 0.25, 0.5, 0.6, 0.75, 1] });

          // observe all current video nodes
          this.$refs.video.forEach(el => this.observer.observe(el));
        },

        playAtIndex(index) {
          // pause all
          this.$refs.video.forEach((v, i) => {
            try {
              if (i === index) {
                // ensure we attempt to play; browsers require muted for autoplay
                this.loadingVideo[i] = true;
                v.muted = true;
                const playPromise = v.play();
                if (playPromise && playPromise.then) {
                  playPromise.then(() => { this.loadingVideo[i] = false; }).catch(() => { this.loadingVideo[i] = false; });
                } else {
                  this.loadingVideo[i] = false;
                }
                v.loop = true;
              } else {
                v.pause();
                v.currentTime = 0; // optional: rewind off-screen videos
                this.progress[i] = 0;
              }
            } catch (e) {
              console.error(e);
            }
          });
        },

        pauseAll() {
          if (!this.$refs.video) return;
          this.$refs.video.forEach(v => {
            try { v.pause(); } catch (e) {}
          });
        },

        playCurrent() {
          this.playAtIndex(this.currentIndex || 0);
        },

        updateProgress(index, event) {
          const video = event.target;
          if (!video.duration) return;
          this.progress[index] = Math.round((video.currentTime / video.duration) * 100);
        },

        onVideoLoaded(index) {
          // called when metadata/frames loaded; hide spinner if set
          this.loadingVideo[index] = false;
        },

        onScroll() {
          // placeholder in case we want to handle touch scrolling specifics
        },

        formatCount(n) {
          if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
          if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
          return n;
        },

        async toggleLike(video, index) {
          // Optimistic UI
          const previousLiked = video.liked;
          const previousLikes = video.likes;
          video.liked = !video.liked;
          video.likes += video.liked ? 1 : -1;

          try {
            const res = await fetch(`/api/videos/${video.id}/like`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ like: video.liked }),
              credentials: 'include'
            });
            if (!res.ok) throw new Error('Like failed');
            // optionally update counts from server response
            const data = await res.json();
            if (data.likes != null) video.likes = data.likes;
          } catch (e) {
            // rollback
            video.liked = previousLiked;
            video.likes = previousLikes;
            console.error(e);
            alert('Failed to update like. Try again.');
          }
        },

        async openComments(video) {
          this.commentsOpen = true;
          this.activeVideo = video;
          this.comments = [];
          this.commentInput = '';
          this.commentsLoading = true;

          try {
            const res = await fetch(`/api/videos/${video.id}/comments`);
            if (!res.ok) throw new Error('Failed to fetch comments');
            const data = await res.json();
            this.comments = data.results || data;
          } catch (e) {
            console.error(e);
            alert('Failed to load comments.');
          } finally {
            this.commentsLoading = false;
          }
        },

        closeComments() {
          this.commentsOpen = false;
          this.activeVideo = null;
        },

        async submitComment() {
          if (!this.activeVideo) return;
          const text = this.commentInput.trim();
          if (!text) return;
          // optimistic add
          const temp = {
            id: 'temp-' + Date.now(),
            text,
            user: { username: 'You', avatar: '/path/to/avatar.png' },
            created_at: 'just now'
          };
          this.comments.unshift(temp);
          this.commentInput = '';
          // increment comments_count in UI
          this.activeVideo.comments_count = (this.activeVideo.comments_count || 0) + 1;

          try {
            const res = await fetch(`/api/videos/${this.activeVideo.id}/comments`, {
              method: 'POST',
              credentials: 'include',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text })
            });
            if (!res.ok) throw new Error('Failed to post comment');
            const saved = await res.json();
            // replace temp comment with saved comment (if server returns it)
            // naive approach: replace first temp id
            const idx = this.comments.findIndex(c => c.id === temp.id);
            if (idx !== -1 && saved) this.comments.splice(idx, 1, saved);
          } catch (e) {
            // rollback UI changes
            this.comments = this.comments.filter(c => c.id !== temp.id);
            this.activeVideo.comments_count = Math.max(0, (this.activeVideo.comments_count || 1) - 1);
            alert('Failed to post comment.');
            console.error(e);
          }
        },

        openProfile(user) {
          // open user profile - replace with your routing
          // If you use client-side routing, navigate there instead.
          window.location.href = `/users/${encodeURIComponent(user.username)}`;
        },

        async shareVideo(video) {
          const shareData = {
            title: 'Check out this video',
            text: video.description || '',
            url: window.location.origin + '/videos/' + video.id
          };
          try {
            if (navigator.share) {
              await navigator.share(shareData);
            } else {
              // fallback: copy url
              await navigator.clipboard.writeText(shareData.url);
              alert('Link copied to clipboard');
            }
          } catch (e) {
            console.error('Share failed', e);
            alert('Unable to share on this device.');
          }
        }
      };
    }
</script>

<!-- Tailwind placeholders for colors (adjust in your config) -->
<style>
    /* small helper for primary color if using plain Tailwind build without config */
    .bg-primary { background-color: #ff0044; }
    .text-primary { color: #ff0044; }
    .from-primary { --tw-gradient-from:#ff0044; }
    .to-secondary { --tw-gradient-to:#ff7a7a; }
</style>

{% include "components/video_interaction_script.html" %}
{% endblock content %}